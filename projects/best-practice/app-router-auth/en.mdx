---
title: 'Next.js: Authentication'
description: 'Server Components, Actions, Middleware'
tags: ['nextjs', 'typescript', 'cookie', 'ssr', 'prisma', 'fsd']
---

<AuthExample />

---

Authentication in Next.js can be quite simple and convenient thanks to the use of server components, Actions and Middleware. Let's look at how you can implement authentication using JWT tokens and sessions using Prisma to work with the database.

## About this approach

Getting user data: `const user = await getUser();`. It's very simple :)

```text hideHeader githubPath="projects" signature="File structure with all the functionality"
src/features/auth
├── api
│   ├── jwt.ts
│   └── session.ts
├── services
│   ├── login.ts
│   ├── logout.ts
│   ├── signup.ts
│   └── user.ts
├── types
│   └── definitions.ts
└── ui
    ├── form-login.tsx
    ├── form-signup.tsx
    └── logout-button.tsx
```

---

## Implementation

### Database

You can choose any database supported for your project: `MongoDB`, `PostgreSQL`, `MySQL`, etc. In this example, we use `MySQL`, but you can replace the connection URL with your database parameters.

In the root folder of the project, create a `.env` file and add a string with the URL of the database connection:

```env hideHeader
DATABASE_URL="mysql://root@localhost:3306/simple-app"
```

> Replace `root`, `password`, `localhost`, and `simple-app` with the corresponding values of your database.

### Using Prisma

You can use any [ORM](https://ru.wikipedia.org/wiki/ORM): `TypeORM`, `Prisma`, `Sequelize` or use handles to create each field, types and relationships in the database. I will use [`Prisma`](https://www.prisma.io)

> **Prisma** is a powerful ORM that makes it easy to work with a database, providing type safety and a convenient API.

<CodeSteps
	steps={[
		{
			title: 'Installation',
			body: () => (
				<p>
					Install the <code>Prisma CLI</code> and the client
				</p>
			),
			code: {
				filename: 'Terminal',
				lang: 'bash',
				text: 'npm install @prisma/client\nnpm install prisma --save-dev',
			},
		},
		{
			title: 'Initialization',
			body: () => (
				<>
					<p>
						Let's run the command to initialize <code>Prisma</code> in our
						the project
					</p>
					<p>
						This will create the <code>prisma</code> directory with the file{' '}
						<code>schema.prisma</code> and the <code> file.env</code>
					</p>
				</>
			),
			code: {
				filename: 'Terminal',
				lang: 'bash',
				text: 'npx prisma init',
			},
		},
		{
			title: 'The data model',
			body: () => (
					<p>
						Open the file <code>prisma/schema.prisma</code> and define the data model. For example, let's create a User model
					</p>
			),
			code: {
				filename: 'schema.prisma',
				lang: 'prisma',
				githubPath: 'prisma/schema.prisma',
				text: `datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
provider = "prisma-client-js"
}

model User {
id Int @id @default(autoincrement())
username String @unique
password String
name String
}`,
},
},
		{
			title: 'Migration',
			body: () => (
					<p>
						Let's perform a migration to create tables in the database based on the schema
					</p>
			),
			code: {
				filename: 'Terminal',
				lang: 'bash',
				text: `npx prisma migrate dev --name init`,
},
},
		{
			title: 'Client Generation',
			body: () => (
					<p>
						After creating the schema and migrating, we will generate a Prisma client for interacting with the database
					</p>
			),
			code: {
				filename: 'Terminal',
				lang: 'bash',
				text: `npx prisma generate`,
},
},
]}
/>

> Here's a quick way to get started with [Prisma](https://www.prisma.io/docs/getting-started/quickstart)

---

### JWT and session

Creating and processing JWT tokens and sessions in files `features/auth/api/jwt.ts` and `features/auth/api/session.ts`

```typescript filename="auth/api/jwt.ts" githubPath="src/features/auth/api/jwt.ts"
import { SignJWT, jwtVerify } from 'jose';
import { SessionPayload } from '../types/definitions';

const secretKey = process.env.SESSION_SECRET;
const encodedKey = new TextEncoder().encode(secretKey);

export async function encrypt(payload: SessionPayload) {
	return new SignJWT(payload)
		.setProtectedHeader({ alg: 'HS256' })
		.setIssuedAt()
		.setExpirationTime('7d')
		.sign(encodedKey);
}

export async function decrypt(session: string | undefined = '') {
	try {
		const { payload } = await jwtVerify(session, encodedKey, {
			algorithms: ['HS256'],
		});
		return payload;
	} catch (error) {
		console.log('Не удалось подтвердить сеанс');
		return null;
	}
}
```

The `features/auth/api/session.ts` implements functions for working with the session:

- **Creating a session:** The `createSession` function generates a JWT with user data and sets it in cookies with security settings (for example, `HttpOnly`, `secure`, `SameSite').
- **Session verification:** The `verifySession` function extracts the JWT from the cookie and verifies its validity. If the session is valid, it returns information about the user; otherwise, it redirects the user to the login page.
- **Deleting a session:** The `deleteSession` function deletes session cookies, thereby terminating the user's session and redirecting him to the login page.

```typescript filename="auth/api/session.ts" githubPath="src/features/auth/api/session.ts"
import 'server-only';

import { cookies } from 'next/headers';
import { decrypt, encrypt } from './jwt';

export async function createSession(userId: string) {
	// Duration 1 day
	const expiresAt = new Date(Date.now() + 1 * 24 * 60 * 60 * 1000);
	const session = await encrypt({ userId, expiresAt });

	cookies().set('session', session, {
		httpOnly: true,
		secure: true,
		expires: expiresAt,
		sameSite: 'lax',
		path: '/',
	});

	redirect('/dashboard');
}

export async function verifySession() {
	const cookie = cookies().get('session')?.value;
	const session = await decrypt(cookie);

	if (!session?.userId) {
		redirect('/login');
		return null;
	}

	return { isAuth: true, userId: Number(session.userId) };
}

export function deleteSession() {
	cookies().delete('session');
	redirect('/login');
}
```

### Validation and types

Using the [`Zod`] library(https://www.npmjs.com/package/zod ) for strict data verification.

The `features/auth/types/definitions.ts` file defines the `LoginFormSchema` validation schemes that ensure that user data meets expectations: required fields, minimum length, and regular expression compliance for the password.

```typescript filename="auth/types/definitions.ts" githubPath="src/features/auth/types/definitions.ts"
import { z } from 'zod';

export const SignupFormSchema = z.object({
	name: z
		.string()
		.min(2, { message: 'Name must be at least 2 characters long.' })
		.trim(),
	username: z
		.string()
		.min(4, { message: 'Be at least 4 characters long' })
		.trim(),
	password: z
		.string()
		.min(8, { message: 'Be at least 8 characters long' })
		.regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })
		.regex(/[0-9]/, { message: 'Contain at least one number.' })
		.regex(/[^a-zA-Z0-9]/, {
			message: 'Contain at least one special character.',
		})
		.trim(),
});

export const LoginFormSchema = z.object({
	username: z.string().min(1, { message: 'Username field must not be empty.' }),
	password: z.string().min(1, { message: 'Password field must not be empty.' }),
});

export type FormState =
	| {
			errors?: {
				username?: string[];
				password?: string[];
				name?: string[];
			};
			message?: string;
	  }
	| undefined;

export type SessionPayload = {
	userId: string | number;
	expiresAt: Date;
};
```

### Authorization

The login function is implemented in `features/auth/services/login.ts'. She performs the following steps:

1. Use `LoginFormSchema` to check the form data for compliance with the requirements;
2. We are looking for a user by username in the database;
3. Compare the entered password with the hash stored in the database using bcrypt;
4. If the data is correct, create a user session using the create Session function.

```typescript filename="login.ts" githubPath="src/features/auth/services/login.ts"
'use server';

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import { createSession } from '../api/session';
import { FormState, LoginFormSchema } from '../types/definitions';

const prisma = new PrismaClient();

export async function login(
	state: FormState,
	formData: FormData,
): Promise<FormState> {
	// 1. Validate form fields
	const validatedFields = LoginFormSchema.safeParse({
		username: formData.get('username'),
		password: formData.get('password'),
	});
	const errorMessage = { message: 'Invalid login credentials.' };

	// If any form fields are invalid, return early
	if (!validatedFields.success) {
		return {
			errors: validatedFields.error.flatten().fieldErrors,
		};
	}

	// 2. Query the database for the user with the given email
	const { username, password } = validatedFields.data;

	const user = await prisma.user.findFirst({
		where: { username },
	});

	if (!user) {
		return errorMessage;
	}

	// 3. Compare the user's password with the hashed password in the database
	const passwordMatch = await bcrypt.compare(password, user.password);

	// If the password does not match, return early
	if (!passwordMatch) {
		return errorMessage;
	}

	// 4. If login successful, create a session for the user and redirect
	const userId = user.id.toString();
	await createSession(userId);
}
```

The `FormLogin` component in `features/auth/ui/form-login/form-login.tsx` is used to create the login interface. This component collects data from the user and passes it to the `login` function.

```tsx filename="form-login.tsx" githubPath="src/features/auth/ui/form-login/form-login.tsx"
'use client';

import { cn } from '@/shared/lib';
import { Button, Input } from '@nextui-org/react';
import { FC } from 'react';
import { useFormState, useFormStatus } from 'react-dom';
import { login } from '../../services/login';

interface FormLoginProps {
	className?: string;
}

export const FormLogin: FC<FormLoginProps> = ({ className }) => {
	const [state, action] = useFormState(login, undefined);
	const { pending } = useFormStatus();

	return (
		<form action={action} className={cn('grid gap-2 h-fit', className)}>
			<Input
				name='username'
				placeholder='Username'
				errorMessage={state?.errors?.username}
				isInvalid={Boolean(state?.errors?.username)}
			/>
			<Input
				name='password'
				placeholder='Password'
				type='password'
				errorMessage={state?.errors?.password}
				isInvalid={Boolean(state?.errors?.password)}
			/>
			<Button
				color='primary'
				aria-disabled={pending}
				type='submit'
				className='mt-2 w-full'
			>
				{pending ? 'Submitting...' : 'Login'}
			</Button>
		</form>
	);
};
```

### Registration

The registration function is implemented in `features/auth/services/signup.ts'. She performs the following steps:

1. Use the `SignupFormSchema` from `features/auth/types/definitions.ts` to check the form data for compliance with the requirements;
2. Query the database to make sure that the username is not already occupied;
3. Use `bcrypt` to hash the password before storing it in the database;
4. Insert a new user record into the user table;
5. After successful registration, we create a session for the user using the `createSession` function from `features/auth/api/session.ts'.

```typescript filename="signup.ts" githubPath="src/features/auth/services/signup.ts"
'use server';

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import { createSession } from '../api/session';
import { FormState, SignupFormSchema } from '../types/definitions';

const prisma = new PrismaClient();

export async function signup(
	state: FormState,
	formData: FormData,
): Promise<FormState> {
	// 1. Validate form fields
	const validatedFields = SignupFormSchema.safeParse({
		name: formData.get('name'),
		username: formData.get('username'),
		password: formData.get('password'),
	});

	// If any form fields are invalid, return early
	if (!validatedFields.success) {
		return {
			errors: validatedFields.error.flatten().fieldErrors,
		};
	}

	// 2. Prepare data for insertion into database
	const { name, username, password } = validatedFields.data;

	// 3. Check if the user's username already exists
	const existingUser = await prisma.user.findFirst({ where: { username } });

	if (existingUser) {
		return {
			message: 'Username already exists, please use a different username.',
		};
	}

	// Hash the user's password
	const hashedPassword = await bcrypt.hash(password, 10);

	// 3. Insert the user into the database or call an Auth Provider's API
	const user = await prisma.user.create({
		data: {
			name,
			username,
			password: hashedPassword,
		},
		select: { id: true },
	});

	if (!user) {
		return {
			message: 'An error occurred while creating your account.',
		};
	}

	// 4. Create a session for the user
	const userId = user.id.toString();
	await createSession(userId);
}
```

`features/auth/ui/form-login/form-signup.tsx`:

```tsx filename="form-signup.tsx" githubPath="src/features/auth/ui/form-signup/form-signup.tsx"
'use client';

import { cn } from '@/shared/lib';
import { Button, Input } from '@nextui-org/react';
import { FC } from 'react';
import { useFormState, useFormStatus } from 'react-dom';
import { signup } from '../../services/signup';

interface FormSignupProps {
	className?: string;
}

export const FormSignup: FC<FormSignupProps> = ({ className }) => {
	const [state, action] = useFormState(signup, undefined);
	const { pending } = useFormStatus();

	return (
		<form action={action} className={cn('grid gap-2 h-fit', className)}>
			<Input
				name='name'
				placeholder='Name'
				errorMessage={state?.errors?.name}
				isInvalid={Boolean(state?.errors?.name)}
			/>
			<Input
				name='username'
				placeholder='Username'
				errorMessage={state?.errors?.username}
				isInvalid={Boolean(state?.errors?.username)}
			/>
			<Input
				name='password'
				placeholder='Password'
				type='password'
				errorMessage={state?.errors?.password}
				isInvalid={Boolean(state?.errors?.password)}
			/>
			<Button
				color='primary'
				aria-disabled={pending}
				type='submit'
				className='mt-2 w-full'
			>
				{pending ? 'Submitting...' : 'Signup'}
			</Button>
		</form>
	);
};
```

### Exit

After successful authentication and session creation, the user needs to be able to log out.

In this section, we implement the user logout functionality by deleting their session and clearing cookies.

`features/auth/services/logout.ts`:

```typescript filename="logout.ts" githubPath="src/features/auth/services/logout.ts"
'use server';

import { deleteSession } from '../api/session';

export async function logout() {
	deleteSession();
}
```

For the convenience of the user, we will add an exit button to the interface.

`features/auth/ui/logout-button/logout-button.tsx`:

```tsx filename="logout-button.tsx" githubPath="src/features/auth/ui/logout-button/logout-button.tsx"
'use client';

import { Dictionary } from '@/shared/config/i18n';
import { Button } from '@nextui-org/react';
import { RxExit } from 'react-icons/rx';
import { logout } from '../../services/logout';

export const LogoutButton = ({ dict }: { dict: Dictionary['ui'] }) => {
	return (
		<Button
			startContent={<RxExit size={18} />}
			color='danger'
			variant='flat'
			size='sm'
			onClick={async () => await logout()}
		>
			{dict['auth-logout']}
		</Button>
	);
};
```

### getUser

`features/auth/services/user.ts` implements the 'getUser`function, which uses`verifySession`to verify the current session and`PrismaClient` to extract user data from the database:

```typescript filename="user.ts" githubPath="src/features/auth/services/user.ts"
import 'server-only';

import { PrismaClient } from '@prisma/client';
import { cache } from 'react';
import { verifySession } from '../api/session';

const prisma = new PrismaClient();

export const getUser = cache(async () => {
	const session = await verifySession();
	if (!session) return null;

	try {
		const user = await prisma.user.findFirst({
			where: {
				id: session.userId,
			},
			select: {
				id: true,
				username: true,
				name: true,
			},
		});

		return user;
	} catch (error) {
		console.log('Failed to fetch user');
		return null;
	}
});
```

## Conclusion

In this article, we have implemented a complete authentication system with registration, login, logout and receipt of user data.

Using `Prisma` to work with the database and `JWT` to manage sessions, we have created a secure and convenient user authentication solution.

Thanks for reading (:
